{"version":3,"file":"components_MapComponent_tsx.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAGA;AACA;AASA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAsBA;AAwBA;AACA;AAxBA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AA6JA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAtMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAoBA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;;AAAA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AAYA;;AACA;AACA;;AAOA;AACA;AAKA;AACA;AAMA;AACA;;;;;;;;;;;;;;;;;;;;;AC5XA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACxFA","sources":["webpack:///./components/MapComponent.tsx","webpack:///./map.ts","webpack:///./mapboxApiKey.ts"],"sourcesContent":["import React from 'react';\nimport { GpxInfo, LatLon } from '../types';\n\nimport { MAPBOX_API_KEY } from '../mapboxApiKey';\nimport {\n    findBounds,\n    findCenter,\n    geoJsonToPoint,\n    pointsToGeoJsonFeature,\n    toGeoJson,\n    toGeoJsonFeature,\n    toGeoJsonLineString,\n} from '../map';\nimport mapboxgl from 'mapbox-gl';\nimport * as turf from '@turf/turf';\n\nconst clamp = (num: number, lo: number, hi: number) =>\n    num < lo ? lo : num > hi ? hi : num;\n\n// Given bearings a and b in the range [-180, 180], return the short angle that moves a to b.\n// examples:\n// if a is 10 and b is -10, then the answer is -20.\n// if a is -10 and b is 10, then the answer is 20.\n// if a is -170 and b is 170, then the answer is -20.\n// if a is 170 and b is -170, then the answer is 20.\nconst bearingDiff = (a: number, b: number) => {\n    // diff will be in the range [0, 360]\n    const diff = Math.abs(b - a);\n    const sign = b > a ? 1 : -1;\n    return sign * (diff > 180 ? -(360 - diff) : diff);\n};\n\n// Fix a bearing between [-360, 360] to [-180, 180]\nconst fixBearingDomain = (b: number) => {\n    if (b < -180) {\n        return 360 + b;\n    } else if (b > 180) {\n        return -360 + b;\n    }\n    return b;\n};\n\ntype Props = {\n    gpxInfo: GpxInfo;\n};\n\ntype State = {\n    useFollowCam: boolean;\n    useFollowTrack: boolean;\n    mapStyle: string;\n    // pointsPerFrame is a fixed value that means the number of points each frame\n    // should advance so the entire route takes 1 minute to finish. Can be a fractional.\n    pointsPerSecond: number;\n    // are we currently playing?\n    isPlaying: boolean;\n    // multiply pointsPerSecond by playbackRate to decide how much to animate per second\n    playbackRate: number;\n    gpxTrackWidth: number;\n    gpxTrackColor: string;\n    pointIcon: string;\n};\n\nexport default class MapComponent extends React.Component<Props, State> {\n    mapDivRef = React.createRef<HTMLDivElement>();\n    progressRef = React.createRef<HTMLProgressElement>();\n\n    map: mapboxgl.Map;\n    // where is the bike along the track? can be fractional, in the range [0, # points]\n    // TODO: can i put this number in the state?\n    playhead: number = 0;\n    lastAnimationTime: number | null = null;\n    animationHandle: number;\n    point = {\n        type: 'FeatureCollection' as const,\n        features: [\n            {\n                type: 'Feature' as const,\n                properties: {} as { [key: string]: unknown },\n                geometry: {\n                    type: 'Point' as const,\n                    coordinates: [0, 0],\n                },\n            },\n        ],\n    };\n\n    constructor(props: Props) {\n        super(props);\n        this.state = {\n            useFollowCam: false,\n            useFollowTrack: false,\n            // mapStyle: 'mapbox://styles/pelmers/cl8ilg939000u15o5hxcr1mjy',\n            mapStyle: 'mapbox://styles/mapbox/outdoors-v11',\n            // divide by 60 seconds per minute\n            pointsPerSecond: props.gpxInfo.points.length / 60,\n            isPlaying: false,\n            playbackRate: 1,\n            gpxTrackWidth: 4,\n            gpxTrackColor: '#ff0',\n            pointIcon: 'bicycle-15',\n        };\n        const origin = toGeoJson(props.gpxInfo.points[0]);\n        this.point.features[0].geometry.coordinates = origin;\n    }\n\n    animationLoop = (t: number) => {\n        if (!this.state.isPlaying) {\n            this.animationHandle = requestAnimationFrame(this.animationLoop);\n            this.lastAnimationTime = null;\n            return;\n        }\n        // cap at 60 fps\n        const minAnimationTime = 16;\n        if (\n            this.lastAnimationTime != null &&\n            t - this.lastAnimationTime > minAnimationTime\n        ) {\n            this.animationBody(t - this.lastAnimationTime);\n        }\n        this.lastAnimationTime = t;\n        this.animationHandle = requestAnimationFrame(this.animationLoop);\n    };\n\n    animationBody(timeDeltaMs: number): void {\n        // Note: times are in milliseconds.\n        const timeDeltaS = timeDeltaMs / 1000;\n        // Compute how many frames to advance the playhead based on the time difference and playback rate\n        const moveDelta =\n            timeDeltaS * this.state.playbackRate * this.state.pointsPerSecond;\n        const { points } = this.props.gpxInfo;\n        const newPosition = Math.min(moveDelta + this.playhead, points.length - 1);\n        this.updatePointPosition(newPosition, timeDeltaS);\n\n        // We've reached the end, pause the playback indicator\n        if (newPosition === points.length - 1) {\n            this.setState({ isPlaying: false });\n        }\n        this.playhead = newPosition;\n    }\n\n    interpolatePoint(position: number) {\n        const { points } = this.props.gpxInfo;\n        const pointIndex = Math.floor(position);\n        const currentFrameFeature = toGeoJsonFeature(points[pointIndex]);\n        const nextFrameFeature = toGeoJsonFeature(points[pointIndex + 1]);\n        const nextDist = turf.distance(currentFrameFeature, nextFrameFeature);\n        const bearing = turf.bearing(currentFrameFeature, nextFrameFeature);\n        return {\n            point: turf.along(\n                toGeoJsonLineString(points[pointIndex], points[pointIndex + 1]),\n                nextDist * (position - pointIndex)\n            ),\n            bearing,\n        };\n    }\n\n    updatePointPosition(newPosition: number, timeDeltaS: number) {\n        const { points } = this.props.gpxInfo;\n        const pointIndex = Math.floor(newPosition);\n        if (pointIndex === points.length - 1) {\n            this.point.features[0] = toGeoJsonFeature(points[pointIndex]);\n            return;\n        }\n\n        const { point, bearing } = this.interpolatePoint(newPosition);\n\n        // TODO: fix a bit of stuttering issue (noticeable in followcam)\n        // @ts-ignore it's okay this is fine\n        this.point.features[0] = point;\n        this.point.features[0].properties.bearing = bearing;\n        (this.map.getSource('point') as mapboxgl.GeoJSONSource).setData(this.point);\n\n        // Update progress bar percentage based on this position\n        if (this.progressRef.current != null) {\n            this.progressRef.current.value = (100 * newPosition) / (points.length - 1);\n        }\n\n        if (this.state.useFollowCam) {\n            const rot = bearingDiff(this.map.getBearing(), bearing);\n            // Cap the camera rotation rate at 90 degrees/second to prevent dizziness\n            // After adding the rotation, reset domain to [-180, 180]\n            // because moving from +170 to -170 is +20, which goes to 190, and out of bounds.\n            const changeCap = 30 * timeDeltaS;\n            const fixedBearing = fixBearingDomain(\n                this.map.getBearing() + clamp(rot, -changeCap, changeCap)\n            );\n            const center = point.geometry.coordinates;\n            this.map.easeTo({\n                // @ts-ignore bug in typings\n                center,\n                bearing: fixedBearing,\n                duration: 0.9 * timeDeltaS * 1000,\n                // Linear move speed\n                easing: (x) => x,\n            });\n        }\n        if (this.state.useFollowTrack) {\n            this.updateTrackDisplay(newPosition);\n        }\n    }\n\n    updateTrackDisplay(position: number) {\n        const pointIndex = Math.floor(position);\n        const { points } = this.props.gpxInfo;\n        if (pointIndex === points.length - 1) {\n            const source = this.map.getSource('gpxTrack') as mapboxgl.GeoJSONSource;\n            source.setData(pointsToGeoJsonFeature(points).data);\n        } else {\n            const sliceToPlayhead = points.slice(0, pointIndex + 1);\n            sliceToPlayhead.push(geoJsonToPoint(this.interpolatePoint(position).point));\n            const source = this.map.getSource('gpxTrack') as mapboxgl.GeoJSONSource;\n            // TODO: this seems to lag with followcam and lots of points?\n            source.setData(pointsToGeoJsonFeature(sliceToPlayhead).data);\n        }\n    }\n\n    componentWillUnmount(): void {\n        if (this.animationHandle != null) {\n            cancelAnimationFrame(this.animationHandle);\n        }\n    }\n\n    async componentDidMount() {\n        const gpsPoints = this.props.gpxInfo.points;\n        this.map = new mapboxgl.Map({\n            container: this.mapDivRef.current!,\n            zoom: 16,\n            pitch: 0,\n            center: findCenter(gpsPoints),\n            style: this.state.mapStyle,\n            accessToken: MAPBOX_API_KEY,\n        });\n        this.map.fitBounds(findBounds(gpsPoints));\n        const addSource = (\n            id: string,\n            points: LatLon[],\n            params: mapboxgl.LinePaint\n        ) => {\n            this.map.addSource(id, pointsToGeoJsonFeature(points)).addLayer({\n                id,\n                type: 'line',\n                source: id,\n                layout: {\n                    'line-join': 'round',\n                    'line-cap': 'round',\n                },\n                paint: params,\n            });\n        };\n\n        await new Promise<void>((resolve) => {\n            this.map.once('styledata', () => {\n                addSource('gpxTrack', gpsPoints, {\n                    'line-color': this.state.gpxTrackColor,\n                    'line-width': this.state.gpxTrackWidth,\n                });\n                this.map.addSource('point', {\n                    type: 'geojson',\n                    data: this.point,\n                });\n\n                this.map.addLayer({\n                    id: 'point',\n                    source: 'point',\n                    type: 'symbol',\n                    layout: {\n                        'icon-image': this.state.pointIcon,\n                        'icon-size': 2,\n                        'icon-allow-overlap': true,\n                        'icon-ignore-placement': true,\n                    },\n                });\n                resolve();\n            });\n        });\n        requestAnimationFrame(this.animationLoop);\n    }\n\n    handleProgressClick = (evt: { nativeEvent: { offsetX: number } }) => {\n        let offsetFraction =\n            evt.nativeEvent.offsetX / this.progressRef.current!.offsetWidth;\n        offsetFraction = Math.max(offsetFraction, 0);\n        offsetFraction = Math.min(offsetFraction, 1);\n        const newPosition = this.props.gpxInfo.points.length * offsetFraction;\n        this.updatePointPosition(newPosition, 0);\n        this.playhead = newPosition;\n    };\n\n    componentWillUpdate(props: Props, nextState: State) {\n        // Did we toggle followcam?\n        if (nextState.useFollowCam !== this.state.useFollowCam) {\n            // Then update the camera on the map\n            if (nextState.useFollowCam) {\n                this.map.easeTo({\n                    zoom: 14.5,\n                    pitch: 60,\n                    center: toGeoJson(props.gpxInfo.points[Math.floor(this.playhead)]),\n                });\n            } else {\n                this.map.easeTo({\n                    pitch: 0,\n                    center: findCenter(props.gpxInfo.points),\n                    animate: false,\n                    bearing: 0,\n                });\n                this.map.fitBounds(findBounds(props.gpxInfo.points));\n            }\n        }\n        if (nextState.useFollowTrack) {\n            this.updateTrackDisplay(this.playhead);\n        } else {\n            this.updateTrackDisplay(props.gpxInfo.points.length - 1);\n        }\n    }\n\n    render() {\n        // TODO outline:\n        // 1. map itself\n        // 2. scrubbable progress bar, and playback rate (also slider?)\n        // 3. followcam toggle\n        // 4. draw route behind toggle\n        // 5. inputs for the different options:\n        //  - constant speed or given speed\n        //  - map style\n        //  - icon type, icon size\n        //  - line color, line thickness\n        // bonus:\n        // - elevation profile?\n        const mb = this.props.gpxInfo.sizeBytes / 1000000;\n        return (\n            <>\n                <div className=\"center gpx-info\">\n                    Selected: <b>{this.props.gpxInfo.name}</b> ({mb.toFixed(2)} MB)\n                </div>\n                <div id=\"map-container\" ref={this.mapDivRef} />\n                <div className=\"center\">\n                    <div className=\"progress-container\">\n                        <button\n                            aria-label=\"Play\"\n                            role=\"button\"\n                            className=\"play-button\"\n                            onClick={() =>\n                                this.setState({ isPlaying: !this.state.isPlaying })\n                            }\n                        >\n                            {this.state.isPlaying ? '❚❚' : '►'}\n                        </button>\n                        <label className=\"play-percent\" role=\"percentage indicator\" />\n                        <progress\n                            max=\"100\"\n                            value=\"0\"\n                            className=\"play-progress\"\n                            ref={this.progressRef}\n                            onClick={this.handleProgressClick}\n                        >\n                            Progress\n                        </progress>\n                    </div>\n                    {/* TODO: options for the things */}\n                </div>\n                <div className=\"center control-group\">\n                    Use FollowCam{' '}\n                    <input\n                        type=\"checkbox\"\n                        defaultChecked={this.state.useFollowCam}\n                        onChange={() =>\n                            this.setState({ useFollowCam: !this.state.useFollowCam })\n                        }\n                    />\n                    Use FollowTrack{' '}\n                    <input\n                        type=\"checkbox\"\n                        defaultChecked={this.state.useFollowTrack}\n                        onChange={() =>\n                            this.setState({\n                                useFollowTrack: !this.state.useFollowTrack,\n                            })\n                        }\n                    />\n                </div>\n            </>\n        );\n    }\n}\n","import { Feature, Point } from '@turf/turf';\nimport { LatLon } from './types';\n\nexport function toGeoJson(point: LatLon): [number, number] {\n    return [point.lon, point.lat];\n}\n\nexport function pointsToGeoJsonFeature(points: LatLon[]) {\n    return {\n        type: 'geojson' as const,\n        data: {\n            type: 'Feature' as const,\n            properties: {},\n            geometry: {\n                type: 'LineString' as const,\n                coordinates: points.map(toGeoJson),\n            },\n        },\n    };\n}\n\nexport function geoJsonToPoint(pt: Feature<Point>): LatLon {\n    const { coordinates } = pt.geometry;\n    return { lon: coordinates[0], lat: coordinates[1] };\n}\n\nexport function toGeoJsonFeature(point: LatLon) {\n    return {\n        type: 'Feature' as const,\n        geometry: {\n            type: 'Point' as const,\n            coordinates: toGeoJson(point),\n        },\n        properties: {},\n    };\n}\n\nexport function toGeoJsonLineString(from: LatLon, to: LatLon) {\n    return {\n        type: 'Feature' as const,\n        geometry: {\n            type: 'LineString' as const,\n            coordinates: [toGeoJson(from), toGeoJson(to)],\n        },\n        properties: {},\n    };\n}\n\nexport function findCenter(gpsPoints: LatLon[]): [number, number] {\n    const n = gpsPoints.length;\n    const avg = gpsPoints.reduce(\n        (prev, cur) => ({\n            lat: prev.lat + cur.lat / n,\n            lon: prev.lon + cur.lon / n,\n        }),\n        { lat: 0, lon: 0 }\n    );\n    return toGeoJson(avg);\n}\n\nexport function findBounds(gpsPoints: LatLon[]): mapboxgl.LngLatBoundsLike {\n    const [sw, ne] = gpsPoints.reduce(\n        ([sw, ne], cur) => [\n            {\n                lat: Math.min(cur.lat, sw.lat),\n                lng: Math.min(cur.lon, sw.lng),\n            },\n            { lat: Math.max(cur.lat, ne.lat), lng: Math.max(cur.lon, ne.lng) },\n        ],\n        [\n            { lat: Number.MAX_SAFE_INTEGER, lng: Number.MAX_SAFE_INTEGER },\n            { lat: Number.MIN_SAFE_INTEGER, lng: Number.MIN_SAFE_INTEGER },\n        ]\n    );\n    // Add padding to every side\n    const pad = 0.15;\n    const x = (ne.lat - sw.lat) * pad;\n    const y = (ne.lng - sw.lng) * pad;\n    return [\n        {\n            lat: sw.lat - x,\n            lng: sw.lng - y,\n        },\n        {\n            lat: ne.lat + x,\n            lng: ne.lng + y,\n        },\n    ];\n}\n","export const MAPBOX_API_KEY =\n    'pk.eyJ1IjoicGVsbWVycyIsImEiOiJjbDg5N2N5Nm0wMzU2M25qeHIzdjl5dm1pIn0.eIGsKaeGa_O7bELSprhD8A';\n"],"names":[],"sourceRoot":""}
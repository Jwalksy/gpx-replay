{"version":3,"file":"components_MapComponent_tsx.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAGA;AACA;AAYA;AACA;AACA;AAyBA;AAwBA;AACA;AAxBA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAuBA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA+FA;AACA;AACA;AACA;AACA;AACA;AACA;AAmBA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AApKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAqBA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAYA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAKA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;;AACA;;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAUA;AASA;AAGA;AACA;AAMA;AACA;AACA;AAOA;AACA;AAKA;AACA;AAIA;AACA;AAWA;AASA;AAEA;AACA;AAGA;AACA;AAGA;AAGA;AAGA;AACA;AACA;AAGA;AAGA;AAGA;AAMA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AASA;AACA;AAKA;AACA;AAGA;AAWA;AACA;;;;;;;;;;;;;;;;;ACrgBA;AAEA;AAWA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAWA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClHA","sources":["webpack:///./components/MapComponent.tsx","webpack:///./components/RangeSliderComponent.tsx","webpack:///./mapTools.ts","webpack:///./mapboxApiKey.ts"],"sourcesContent":["import React from 'react';\nimport { GpxInfo, LatLon } from '../types';\n\nimport { MAPBOX_API_KEY } from '../mapboxApiKey';\nimport {\n    bearingDiff,\n    clamp,\n    findBounds,\n    findCenter,\n    fixBearingDomain,\n    geoJsonToPoint,\n    pointsToGeoJsonFeature,\n    toGeoJson,\n    toGeoJsonFeature,\n    toGeoJsonLineString,\n} from '../mapTools';\nimport mapboxgl from 'mapbox-gl';\nimport * as turf from '@turf/turf';\nimport RangeSliderComponent from './RangeSliderComponent';\n\ntype Props = {\n    gpxInfo: GpxInfo;\n    bindSpace: boolean;\n};\n\ntype State = {\n    useFollowCam: boolean;\n    followSensitivity: number;\n    useFollowTrack: boolean;\n    mapStyle: string;\n    // pointsPerSecond is a fixed value that means the number of points each frame\n    // should advance so the entire route takes 1 minute to finish. Can be a fractional.\n    pointsPerSecond: number;\n    // are we currently playing?\n    isPlaying: boolean;\n    // multiply pointsPerSecond by playbackRate to decide how much to animate per second\n    playbackRate: number;\n    gpxTrackWidth: number;\n    gpxTrackColor: string;\n    pointIcon: string;\n    pointIconSize: number;\n};\n\nexport default class MapComponent extends React.Component<Props, State> {\n    mapDivRef = React.createRef<HTMLDivElement>();\n    progressRef = React.createRef<HTMLProgressElement>();\n\n    map: mapboxgl.Map;\n    // where is the bike along the track? can be fractional, in the range [0, # points]\n    // TODO: can i put this number in the state?\n    playhead: number = 0;\n    lastAnimationTime: number | null = null;\n    animationHandle: number;\n    point = {\n        type: 'FeatureCollection' as const,\n        features: [\n            {\n                type: 'Feature' as const,\n                properties: {} as { [key: string]: unknown },\n                geometry: {\n                    type: 'Point' as const,\n                    coordinates: [0, 0],\n                },\n            },\n        ],\n    };\n\n    constructor(props: Props) {\n        super(props);\n        this.state = {\n            useFollowCam: false,\n            followSensitivity: 45,\n            useFollowTrack: false,\n            // mapStyle: 'mapbox://styles/pelmers/cl8ilg939000u15o5hxcr1mjy',\n            mapStyle: 'mapbox://styles/mapbox/outdoors-v11',\n            // divide by 60 seconds per minute\n            pointsPerSecond: props.gpxInfo.points.length / 60,\n            isPlaying: false,\n            playbackRate: 1,\n            gpxTrackWidth: 4,\n            gpxTrackColor: '#ffff00',\n            pointIcon: 'bicycle-15',\n            pointIconSize: 2,\n        };\n        const origin = toGeoJson(props.gpxInfo.points[0]);\n        this.point.features[0].geometry.coordinates = origin;\n    }\n\n    animationLoop = (t: number) => {\n        if (!this.state.isPlaying) {\n            this.animationHandle = requestAnimationFrame(this.animationLoop);\n            this.lastAnimationTime = null;\n            return;\n        } else if (this.lastAnimationTime == null) {\n            this.animationHandle = requestAnimationFrame(this.animationLoop);\n            this.lastAnimationTime = t;\n            return;\n        }\n        // cap at 120 fps\n        const minAnimationTime = 1000 / 40;\n        if (t - this.lastAnimationTime > minAnimationTime) {\n            this.animationBody(t - this.lastAnimationTime);\n            this.lastAnimationTime = t;\n        }\n        this.animationHandle = requestAnimationFrame(this.animationLoop);\n    };\n\n    animationBody(timeDeltaMs: number): void {\n        // Note: times are in milliseconds.\n        const timeDeltaS = timeDeltaMs / 1000;\n        // Compute how many frames to advance the playhead based on the time difference and playback rate\n        const moveDelta =\n            timeDeltaS * this.state.playbackRate * this.state.pointsPerSecond;\n        const { points } = this.props.gpxInfo;\n        const newPosition = Math.min(moveDelta + this.playhead, points.length - 1);\n        this.updatePointPosition(newPosition, timeDeltaS);\n\n        // We've reached the end, pause the playback indicator\n        if (newPosition === points.length - 1) {\n            this.setState({ isPlaying: false });\n        }\n        this.playhead = newPosition;\n    }\n\n    interpolatePoint(position: number) {\n        const { points } = this.props.gpxInfo;\n        const pointIndex = Math.floor(position);\n        const currentFrameFeature = toGeoJsonFeature(points[pointIndex]);\n        const nextFrameFeature = toGeoJsonFeature(points[pointIndex + 1]);\n        const nextDist = turf.distance(currentFrameFeature, nextFrameFeature);\n        const bearing = turf.bearing(currentFrameFeature, nextFrameFeature);\n        return {\n            point: turf.along(\n                toGeoJsonLineString(points[pointIndex], points[pointIndex + 1]),\n                nextDist * (position - pointIndex)\n            ),\n            bearing,\n        };\n    }\n\n    updatePointPosition(newPosition: number, timeDeltaS: number) {\n        const { points } = this.props.gpxInfo;\n        const pointIndex = Math.floor(newPosition);\n        if (pointIndex === points.length - 1) {\n            this.point.features[0] = toGeoJsonFeature(points[pointIndex]);\n            return;\n        }\n\n        const { point, bearing } = this.interpolatePoint(newPosition);\n\n        // TODO: fix a bit of stuttering issue (noticeable in followcam)\n        // @ts-ignore it's okay this is fine\n        this.point.features[0] = point;\n        this.point.features[0].properties.bearing = bearing;\n        (this.map.getSource('point') as mapboxgl.GeoJSONSource).setData(this.point);\n\n        // Update progress bar percentage based on this position\n        if (this.progressRef.current != null) {\n            this.progressRef.current.value = (100 * newPosition) / (points.length - 1);\n        }\n\n        if (this.state.useFollowCam) {\n            const rot = bearingDiff(this.map.getBearing(), bearing);\n            // Cap the camera rotation rate at 30 degrees/second to prevent dizziness\n            // After adding the rotation, reset domain to [-180, 180]\n            // because moving from +170 to -170 is +20, which goes to 190, and out of bounds.\n            const changeCap = this.state.followSensitivity * timeDeltaS;\n            const fixedBearing = fixBearingDomain(\n                this.map.getBearing() + clamp(rot, -changeCap, changeCap)\n            );\n            const center = point.geometry.coordinates;\n            this.map.easeTo({\n                // @ts-ignore bug in typings\n                center,\n                bearing: fixedBearing,\n                duration: timeDeltaS * 1000,\n                // Linear move speed\n                easing: (x) => x,\n            });\n        }\n        if (this.state.useFollowTrack) {\n            this.updateTrackDisplay(newPosition);\n        }\n    }\n\n    updateTrackDisplay(position: number) {\n        const pointIndex = Math.floor(position);\n        const { points } = this.props.gpxInfo;\n        if (pointIndex === points.length - 1) {\n            const source = this.map.getSource('gpxTrack') as mapboxgl.GeoJSONSource;\n            source.setData(pointsToGeoJsonFeature(points).data);\n        } else {\n            const sliceToPlayhead = points.slice(0, pointIndex + 1);\n            sliceToPlayhead.push(geoJsonToPoint(this.interpolatePoint(position).point));\n            const source = this.map.getSource('gpxTrack') as mapboxgl.GeoJSONSource;\n            // TODO: this seems to lag with followcam and lots of points?\n            source.setData(pointsToGeoJsonFeature(sliceToPlayhead).data);\n        }\n    }\n\n    windowSpaceBind = (e: KeyboardEvent) => {\n        if (e.code === 'Space') {\n            e.preventDefault();\n            e.stopPropagation();\n            this.setState({ isPlaying: !this.state.isPlaying });\n        }\n    };\n\n    componentWillUnmount(): void {\n        if (this.animationHandle != null) {\n            cancelAnimationFrame(this.animationHandle);\n        }\n        if (this.props.bindSpace) {\n            window.removeEventListener('keydown', this.windowSpaceBind);\n        }\n    }\n\n    async componentDidMount() {\n        await this.createMapFromState(this.state);\n        if (this.props.bindSpace) {\n            // Bind window space to play/pause\n            window.addEventListener('keydown', this.windowSpaceBind);\n        }\n    }\n\n    handleProgressClick = (evt: { nativeEvent: { offsetX: number } }) => {\n        let offsetFraction =\n            evt.nativeEvent.offsetX / this.progressRef.current!.offsetWidth;\n        offsetFraction = Math.max(offsetFraction, 0);\n        offsetFraction = Math.min(offsetFraction, 1);\n        const newPosition = this.props.gpxInfo.points.length * offsetFraction;\n        this.updatePointPosition(newPosition, 0);\n        this.playhead = newPosition;\n    };\n\n    async createMapFromState(state: State) {\n        if (this.animationHandle != null) {\n            cancelAnimationFrame(this.animationHandle);\n        }\n        const gpsPoints = this.props.gpxInfo.points;\n        if (this.map == null) {\n            this.map = new mapboxgl.Map({\n                container: this.mapDivRef.current!,\n                zoom: 16,\n                pitch: 0,\n                center: findCenter(gpsPoints),\n                style: state.mapStyle,\n                accessToken: MAPBOX_API_KEY,\n            });\n            this.map.fitBounds(findBounds(gpsPoints));\n        } else {\n            // If we have already loaded the map, just set the style. Otherwise it's billable\n            this.map.setStyle(state.mapStyle);\n        }\n        const addSource = (\n            id: string,\n            points: LatLon[],\n            params: mapboxgl.LinePaint\n        ) => {\n            this.map.addSource(id, pointsToGeoJsonFeature(points)).addLayer({\n                id,\n                type: 'line',\n                source: id,\n                layout: {\n                    'line-join': 'round',\n                    'line-cap': 'round',\n                },\n                paint: params,\n            });\n        };\n\n        await new Promise<void>((resolve) => {\n            this.map.once('styledata', () => {\n                addSource('gpxTrack', gpsPoints, {\n                    'line-color': state.gpxTrackColor,\n                    'line-width': state.gpxTrackWidth,\n                });\n                this.map.addSource('point', {\n                    type: 'geojson',\n                    data: this.point,\n                });\n\n                this.map.addLayer({\n                    id: 'point',\n                    source: 'point',\n                    type: 'symbol',\n                    layout: {\n                        'icon-image': state.pointIcon,\n                        'icon-size': state.pointIconSize,\n                        'icon-allow-overlap': true,\n                        'icon-ignore-placement': true,\n                    },\n                });\n                if (this.state.useFollowTrack) {\n                    this.updateTrackDisplay(this.playhead);\n                }\n                resolve();\n            });\n        });\n        requestAnimationFrame(this.animationLoop);\n    }\n\n    async componentWillUpdate(props: Props, nextState: State) {\n        // Did we toggle followcam?\n        if (nextState.useFollowCam !== this.state.useFollowCam) {\n            // Then update the camera on the map\n            if (nextState.useFollowCam) {\n                this.map.easeTo({\n                    zoom: 14.5,\n                    pitch: 60,\n                    center: toGeoJson(props.gpxInfo.points[Math.floor(this.playhead)]),\n                });\n            } else {\n                this.map.easeTo({\n                    pitch: 0,\n                    center: findCenter(props.gpxInfo.points),\n                    animate: false,\n                    bearing: 0,\n                });\n                this.map.fitBounds(findBounds(props.gpxInfo.points));\n            }\n        }\n        if (nextState.useFollowTrack) {\n            this.updateTrackDisplay(this.playhead);\n        } else {\n            this.updateTrackDisplay(props.gpxInfo.points.length - 1);\n        }\n        if (nextState.mapStyle !== this.state.mapStyle) {\n            // Changing the style also resets the track and stuff, just re-create it.\n            await this.createMapFromState(nextState);\n        }\n        if (nextState.pointIcon !== this.state.pointIcon) {\n            this.map.setLayoutProperty('point', 'icon-image', nextState.pointIcon);\n        }\n        if (nextState.pointIconSize !== this.state.pointIconSize) {\n            this.map.setLayoutProperty('point', 'icon-size', nextState.pointIconSize);\n        }\n        if (nextState.gpxTrackColor !== this.state.gpxTrackColor) {\n            this.map.setPaintProperty(\n                'gpxTrack',\n                'line-color',\n                nextState.gpxTrackColor\n            );\n        }\n        if (nextState.gpxTrackWidth !== this.state.gpxTrackWidth) {\n            this.map.setPaintProperty(\n                'gpxTrack',\n                'line-width',\n                nextState.gpxTrackWidth\n            );\n        }\n    }\n\n    render() {\n        // TODO bonus: elevation profile?\n        const mb = this.props.gpxInfo.sizeBytes / 1000000;\n        return (\n            <>\n                <div className=\"center gpx-info\">\n                    Selected: <b>{this.props.gpxInfo.name}</b> ({mb.toFixed(2)} MB)\n                </div>\n                <div className=\"map-container-container\">\n                    <div id=\"map-container\" ref={this.mapDivRef} />\n                </div>\n                <div className=\"center\">\n                    <div className=\"progress-container\">\n                        <button\n                            aria-label=\"Play\"\n                            role=\"button\"\n                            className=\"play-button\"\n                            onClick={() =>\n                                this.setState({ isPlaying: !this.state.isPlaying })\n                            }\n                        >\n                            {this.state.isPlaying ? '❚❚' : '►'}\n                        </button>\n                        <progress\n                            max=\"100\"\n                            value=\"0\"\n                            className=\"play-progress\"\n                            ref={this.progressRef}\n                            onClick={this.handleProgressClick}\n                        >\n                            Progress\n                        </progress>\n                        <button\n                            className=\"fullscreen-button\"\n                            onClick={() => {\n                                this.mapDivRef.current!.requestFullscreen();\n                            }}\n                        >\n                            Fullscreen\n                        </button>\n                    </div>\n                </div>\n                <div className=\"center first-control-group\">\n                    <label>FollowCam</label>\n                    <input\n                        type=\"checkbox\"\n                        defaultChecked={this.state.useFollowCam}\n                        onChange={() =>\n                            this.setState({ useFollowCam: !this.state.useFollowCam })\n                        }\n                    />\n                    <label>FollowTrack</label>\n                    <input\n                        type=\"checkbox\"\n                        defaultChecked={this.state.useFollowTrack}\n                        onChange={() =>\n                            this.setState({\n                                useFollowTrack: !this.state.useFollowTrack,\n                            })\n                        }\n                    />\n                </div>\n                <div className=\"center control-group\">\n                    {this.state.useFollowCam && (\n                        <RangeSliderComponent\n                            label=\"Follow Sensitivity\"\n                            min={0}\n                            max={180}\n                            step={1}\n                            value={this.state.followSensitivity}\n                            onChange={(v) => this.setState({ followSensitivity: v })}\n                        />\n                    )}\n\n                    <RangeSliderComponent\n                        label={'Playback Rate'}\n                        min={0.2}\n                        max={20}\n                        step={0.2}\n                        value={this.state.playbackRate}\n                        onChange={(value) => this.setState({ playbackRate: value })}\n                    />\n                </div>\n                <div className=\"center control-group\">\n                    {/* styles from https://docs.mapbox.com/api/maps/styles/ */}\n                    <label htmlFor=\"map-style\">Map Style</label>\n                    <select\n                        name=\"map style\"\n                        onChange={(evt) => {\n                            this.setState({ mapStyle: evt.target.value });\n                        }}\n                        defaultValue={this.state.mapStyle}\n                    >\n                        <option value=\"mapbox://styles/mapbox/outdoors-v11\">\n                            Outdoors\n                        </option>\n                        <option value=\"mapbox://styles/mapbox/streets-v11\">\n                            Streets\n                        </option>\n                        <option value=\"mapbox://styles/mapbox/light-v10\">Light</option>\n                        <option value=\"mapbox://styles/mapbox/dark-v10\">Dark</option>\n                        <option value=\"mapbox://styles/mapbox/satellite-v9\">\n                            Satellite\n                        </option>\n                        <option value=\"mapbox://styles/mapbox/satellite-streets-v11\">\n                            Satellite Streets\n                        </option>\n                        <option value=\"mapbox://styles/mapbox/navigation-day-v1\">\n                            Navigation Day\n                        </option>\n                        <option value=\"mapbox://styles/mapbox/navigation-night-v1\">\n                            Navigation Night\n                        </option>\n                    </select>\n\n                    {/* List available at https://github.com/mapbox/mapbox-gl-styles#standard-icons  */}\n                    <label>Point Icon</label>\n                    <select\n                        defaultValue={this.state.pointIcon}\n                        onChange={(evt) => {\n                            this.setState({ pointIcon: evt.target.value });\n                        }}\n                    >\n                        <option value=\"bicycle-15\">Bicycle</option>\n                        <option value=\"rocket-15\">Rocket</option>\n                        <option value=\"swimming-15\">Swimmer</option>\n                        <option value=\"bus-15\">Bus</option>\n                        <option value=\"rail-15\">Train</option>\n                        <option value=\"pitch-15\">Runner</option>\n                        <option value=\"car-15\">Death Cage</option>\n                        <option value=\"circle-15\">Circle</option>\n                    </select>\n\n                    <RangeSliderComponent\n                        label={'Point Icon Size'}\n                        min={0.0}\n                        max={25}\n                        step={0.5}\n                        value={this.state.pointIconSize}\n                        onChange={(value) => this.setState({ pointIconSize: value })}\n                    />\n\n                    <label htmlFor=\"line-color\">Line Color</label>\n                    <input\n                        type=\"color\"\n                        name=\"line-color\"\n                        defaultValue={this.state.gpxTrackColor}\n                        onChange={(ev) => {\n                            this.setState({ gpxTrackColor: ev.target.value });\n                        }}\n                    />\n\n                    <RangeSliderComponent\n                        label={'Line Thickness'}\n                        min={0.0}\n                        max={30}\n                        step={0.5}\n                        value={this.state.gpxTrackWidth}\n                        onChange={(value) => this.setState({ gpxTrackWidth: value })}\n                    />\n                </div>\n            </>\n        );\n    }\n}\n","// React component that renders a range slider with a label and callback on change\n\nimport React from 'react';\n\ntype Props = {\n    label: string;\n    min: number;\n    max: number;\n    value: number;\n    step: number;\n    onChange: (value: number) => unknown;\n};\n\nexport default class RangeSliderComponent extends React.Component<Props, {}> {\n    render() {\n        return (\n            <>\n                <label>{this.props.label}</label>\n                <div style={{ display: 'inline' }}>\n                    <label style={{ marginRight: '25px' }}>\n                        {this.props.value.toFixed(1)}\n                    </label>\n                    <input\n                        type=\"range\"\n                        min={this.props.min}\n                        max={this.props.max}\n                        step={this.props.step}\n                        value={this.props.value}\n                        onChange={(e) => this.props.onChange(Number(e.target.value))}\n                    />\n                </div>\n            </>\n        );\n    }\n}\n","import { Feature, Point } from '@turf/turf';\nimport { LatLon } from './types';\n\nexport function toGeoJson(point: LatLon): [number, number] {\n    return [point.lon, point.lat];\n}\n\nexport function pointsToGeoJsonFeature(points: LatLon[]) {\n    return {\n        type: 'geojson' as const,\n        data: {\n            type: 'Feature' as const,\n            properties: {},\n            geometry: {\n                type: 'LineString' as const,\n                coordinates: points.map(toGeoJson),\n            },\n        },\n    };\n}\n\nexport function geoJsonToPoint(pt: Feature<Point>): LatLon {\n    const { coordinates } = pt.geometry;\n    return { lon: coordinates[0], lat: coordinates[1] };\n}\n\nexport function toGeoJsonFeature(point: LatLon) {\n    return {\n        type: 'Feature' as const,\n        geometry: {\n            type: 'Point' as const,\n            coordinates: toGeoJson(point),\n        },\n        properties: {},\n    };\n}\n\nexport function toGeoJsonLineString(from: LatLon, to: LatLon) {\n    return {\n        type: 'Feature' as const,\n        geometry: {\n            type: 'LineString' as const,\n            coordinates: [toGeoJson(from), toGeoJson(to)],\n        },\n        properties: {},\n    };\n}\n\nexport function findCenter(gpsPoints: LatLon[]): [number, number] {\n    const n = gpsPoints.length;\n    const avg = gpsPoints.reduce(\n        (prev, cur) => ({\n            lat: prev.lat + cur.lat / n,\n            lon: prev.lon + cur.lon / n,\n        }),\n        { lat: 0, lon: 0 }\n    );\n    return toGeoJson(avg);\n}\n\nexport function findBounds(gpsPoints: LatLon[]): mapboxgl.LngLatBoundsLike {\n    const [sw, ne] = gpsPoints.reduce(\n        ([sw, ne], cur) => [\n            {\n                lat: Math.min(cur.lat, sw.lat),\n                lng: Math.min(cur.lon, sw.lng),\n            },\n            { lat: Math.max(cur.lat, ne.lat), lng: Math.max(cur.lon, ne.lng) },\n        ],\n        [\n            { lat: Number.MAX_SAFE_INTEGER, lng: Number.MAX_SAFE_INTEGER },\n            { lat: Number.MIN_SAFE_INTEGER, lng: Number.MIN_SAFE_INTEGER },\n        ]\n    );\n    // Add padding to every side\n    const pad = 0.15;\n    const x = (ne.lat - sw.lat) * pad;\n    const y = (ne.lng - sw.lng) * pad;\n    return [\n        {\n            lat: sw.lat - x,\n            lng: sw.lng - y,\n        },\n        {\n            lat: ne.lat + x,\n            lng: ne.lng + y,\n        },\n    ];\n}\n\nexport const clamp = (num: number, lo: number, hi: number) =>\n    num < lo ? lo : num > hi ? hi : num;\n\n// Given bearings a and b in the range [-180, 180], return the short angle that moves a to b.\n// examples:\n// if a is 10 and b is -10, then the answer is -20.\n// if a is -10 and b is 10, then the answer is 20.\n// if a is -170 and b is 170, then the answer is -20.\n// if a is 170 and b is -170, then the answer is 20.\nexport const bearingDiff = (a: number, b: number) => {\n    // diff will be in the range [0, 360]\n    const diff = Math.abs(b - a);\n    const sign = b > a ? 1 : -1;\n    return sign * (diff > 180 ? -(360 - diff) : diff);\n};\n\n// Fix a bearing between [-360, 360] to [-180, 180]\nexport const fixBearingDomain = (b: number) => {\n    if (b < -180) {\n        return 360 + b;\n    } else if (b > 180) {\n        return -360 + b;\n    }\n    return b;\n};\n","export const MAPBOX_API_KEY =\n    'pk.eyJ1IjoicGVsbWVycyIsImEiOiJjbDhrbjIyYnUwejhyM3ZyMDVlZnB2a3h6In0.M-JOZDdOSziLjIVuHLhXjw';\n"],"names":[],"sourceRoot":""}
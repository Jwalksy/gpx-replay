{"version":3,"file":"components_MapComponent_tsx.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAGA;AACA;AAOA;AACA;AAkBA;AAwBA;AACA;AAxBA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAeA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;;AAAA;AACA;AACA;AACA;AACA;AACA;AAUA;AAEA;AAcA;AACA;;;;;;;;;;;;;;;;;;;ACnPA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrEA","sources":["webpack:///./components/MapComponent.tsx","webpack:///./map.ts","webpack:///./mapboxApiKey.ts"],"sourcesContent":["import React from 'react';\nimport { GpxInfo, LatLon } from '../types';\n\nimport { MAPBOX_API_KEY } from '../mapboxApiKey';\nimport {\n    findBounds,\n    findCenter,\n    toGeoJson,\n    toGeoJsonFeature,\n    toGeoJsonLineString,\n} from '../map';\nimport mapboxgl from 'mapbox-gl';\nimport * as turf from '@turf/turf';\n\ntype Props = {\n    gpxInfo: GpxInfo;\n};\n\ntype State = {\n    useFollowCam: boolean;\n    mapStyle: string;\n    // pointsPerFrame is a fixed value that means the number of points each frame\n    // should advance so the entire route takes 1 minute to finish. Can be a fractional.\n    pointsPerSecond: number;\n    // are we currently playing?\n    isPlaying: boolean;\n    // multiply pointsPerSecond by playbackRate to decide how much to animate per second\n    playbackRate: number;\n};\n\nexport default class MapComponent extends React.Component<Props, State> {\n    mapDivRef = React.createRef<HTMLDivElement>();\n    progressRef = React.createRef<HTMLProgressElement>();\n\n    map: mapboxgl.Map;\n    // where is the bike along the track? can be fractional, in the range [0, # points]\n    // TODO: can i put this number in the state?\n    playhead: number = 0;\n    lastAnimationTime: number | null = null;\n    animationHandle: number;\n    point = {\n        type: 'FeatureCollection' as const,\n        features: [\n            {\n                type: 'Feature' as const,\n                properties: {} as { [key: string]: unknown },\n                geometry: {\n                    type: 'Point' as const,\n                    coordinates: [0, 0],\n                },\n            },\n        ],\n    };\n\n    constructor(props: Props) {\n        super(props);\n        this.state = {\n            useFollowCam: true,\n            // mapStyle: 'mapbox://styles/pelmers/cl8ilg939000u15o5hxcr1mjy',\n            mapStyle: 'mapbox://styles/mapbox/outdoors-v11',\n            // divide by 60 seconds per minute\n            pointsPerSecond: props.gpxInfo.points.length / 60,\n            isPlaying: false,\n            playbackRate: 5,\n        };\n        const origin = toGeoJson(props.gpxInfo.points[0]);\n        this.point.features[0].geometry.coordinates = origin;\n    }\n\n    animationLoop = (t: number) => {\n        if (!this.state.isPlaying) {\n            this.animationHandle = requestAnimationFrame(this.animationLoop);\n            this.lastAnimationTime = null;\n            return;\n        }\n        if (this.lastAnimationTime != null) {\n            this.animationBody(t - this.lastAnimationTime);\n        }\n        this.lastAnimationTime = t;\n        this.animationHandle = requestAnimationFrame(this.animationLoop);\n    };\n\n    animationBody(timeDeltaMs: number): void {\n        // Note: times are in milliseconds.\n        const timeDeltaS = timeDeltaMs / 1000;\n        // Compute how many frames to advance the playhead based on the time difference and playback rate\n        const moveDelta =\n            timeDeltaS * this.state.playbackRate * this.state.pointsPerSecond;\n        const { points } = this.props.gpxInfo;\n        const newPosition = Math.min(moveDelta + this.playhead, points.length - 1);\n        this.updatePointPosition(newPosition);\n\n        // We've reached the end, pause the playback indicator\n        if (newPosition === points.length - 1) {\n            this.setState({ isPlaying: false });\n        }\n        this.playhead = newPosition;\n    }\n\n    updatePointPosition(newPosition: number) {\n        const { points } = this.props.gpxInfo;\n        const pointIndex = Math.floor(newPosition);\n        if (pointIndex === points.length - 1) {\n            this.point.features[0] = toGeoJsonFeature(points[pointIndex]);\n            return;\n        }\n        const currentFrameFeature = toGeoJsonFeature(points[pointIndex]);\n        const nextFrameFeature = toGeoJsonFeature(points[pointIndex + 1]);\n\n        const nextBearing = turf.bearing(currentFrameFeature, nextFrameFeature);\n        const nextDist = turf.distance(currentFrameFeature, nextFrameFeature);\n        const interpPoint = turf.along(\n            toGeoJsonLineString(points[pointIndex], points[pointIndex + 1]),\n            nextDist * (newPosition - pointIndex)\n        );\n\n        // @ts-ignore it's okay this is fine\n        this.point.features[0] = interpPoint;\n        this.point.features[0].properties.bearing = nextBearing;\n        (this.map.getSource('point') as mapboxgl.GeoJSONSource).setData(this.point);\n    }\n\n    componentWillUnmount(): void {\n        if (this.animationHandle != null) {\n            cancelAnimationFrame(this.animationHandle);\n        }\n    }\n\n    async componentDidMount() {\n        const gpsPoints = this.props.gpxInfo.points;\n        this.map = new mapboxgl.Map({\n            container: this.mapDivRef.current!,\n            zoom: 16,\n            pitch: 0,\n            center: findCenter(gpsPoints),\n            style: this.state.mapStyle,\n            accessToken: MAPBOX_API_KEY,\n        });\n        this.map.fitBounds(findBounds(gpsPoints));\n        const addSource = (\n            id: string,\n            points: LatLon[],\n            params: mapboxgl.LinePaint\n        ) => {\n            this.map\n                .addSource(id, {\n                    type: 'geojson',\n                    data: {\n                        type: 'Feature',\n                        properties: {},\n                        geometry: {\n                            type: 'LineString',\n                            coordinates: points.map(toGeoJson),\n                        },\n                    },\n                })\n                .addLayer({\n                    id,\n                    type: 'line',\n                    source: id,\n                    layout: {\n                        'line-join': 'round',\n                        'line-cap': 'round',\n                    },\n                    paint: params,\n                });\n        };\n\n        await new Promise<void>((resolve) => {\n            this.map.once('styledata', () => {\n                addSource('gpxTrack', gpsPoints, {\n                    // TODO: let user pick color/width?\n                    'line-color': '#ff0',\n                    'line-width': 4,\n                });\n                this.map.addSource('point', {\n                    type: 'geojson',\n                    data: this.point,\n                });\n\n                this.map.addLayer({\n                    id: 'point',\n                    source: 'point',\n                    type: 'symbol',\n                    layout: {\n                        // TODO: allow customize the icon\n                        'icon-image': 'bicycle-15',\n                        'icon-size': 2,\n                        'icon-allow-overlap': true,\n                        'icon-ignore-placement': true,\n                    },\n                });\n                resolve();\n            });\n        });\n        requestAnimationFrame(this.animationLoop);\n    }\n\n    render() {\n        // TODO outline:\n        // 1. map itself\n        // 2. scrubbable progress bar, and playback rate (also slider?)\n        // 3. followcam toggle\n        // 4. inputs for the different options:\n        //  - constant speed or given speed\n        //  - map style\n        //  - icon type, icon size\n        //  - line color, line thickness\n        // bonus:\n        // - elevation profile?\n        const mb = this.props.gpxInfo.sizeBytes / 1000000;\n        return (\n            <>\n                <div className=\"center gpx-info\">\n                    Selected: <b>{this.props.gpxInfo.name}</b> ({mb.toFixed(2)} MB)\n                </div>\n                <div id=\"map-container\" ref={this.mapDivRef} />\n                <div className=\"center\">\n                    <div className=\"progress-container\">\n                        <button\n                            aria-label=\"Play\"\n                            role=\"button\"\n                            className=\"play-button\"\n                            onClick={() =>\n                                this.setState({ isPlaying: !this.state.isPlaying })\n                            }\n                        >\n                            {this.state.isPlaying ? '❚❚' : '►'}\n                        </button>\n                        <label className=\"play-percent\" role=\"percentage indicator\" />\n                        {/* TODO: on seek, update the icon position */}\n                        <progress\n                            max=\"100\"\n                            value=\"0\"\n                            className=\"play-progress\"\n                            ref={this.progressRef}\n                            onClick={(evt) => {}}\n                        >\n                            Progress\n                        </progress>\n                    </div>\n                    {/* TODO: options for the things */}\n                </div>\n            </>\n        );\n    }\n}\n","import { MAPBOX_API_KEY } from './mapboxApiKey';\nimport { LatLon } from './types';\n\nexport function toGeoJson(point: LatLon): [number, number] {\n    return [point.lon, point.lat];\n}\n\nexport function toGeoJsonFeature(point: LatLon) {\n    return {\n        type: 'Feature' as const,\n        geometry: {\n            type: 'Point' as const,\n            coordinates: toGeoJson(point),\n        },\n        properties: {},\n    };\n}\n\nexport function toGeoJsonLineString(from: LatLon, to: LatLon) {\n    return {\n        type: 'Feature' as const,\n        geometry: {\n            type: 'LineString' as const,\n            coordinates: [toGeoJson(from), toGeoJson(to)],\n        },\n        properties: {},\n    };\n}\n\nexport function findCenter(gpsPoints: LatLon[]): [number, number] {\n    const n = gpsPoints.length;\n    const avg = gpsPoints.reduce(\n        (prev, cur) => ({\n            lat: prev.lat + cur.lat / n,\n            lon: prev.lon + cur.lon / n,\n        }),\n        { lat: 0, lon: 0 }\n    );\n    return toGeoJson(avg);\n}\n\nexport function findBounds(gpsPoints: LatLon[]): mapboxgl.LngLatBoundsLike {\n    const [sw, ne] = gpsPoints.reduce(\n        ([sw, ne], cur) => [\n            {\n                lat: Math.min(cur.lat, sw.lat),\n                lng: Math.min(cur.lon, sw.lng),\n            },\n            { lat: Math.max(cur.lat, ne.lat), lng: Math.max(cur.lon, ne.lng) },\n        ],\n        [\n            { lat: Number.MAX_SAFE_INTEGER, lng: Number.MAX_SAFE_INTEGER },\n            { lat: Number.MIN_SAFE_INTEGER, lng: Number.MIN_SAFE_INTEGER },\n        ]\n    );\n    // Add padding to every side\n    const pad = 0.15;\n    const x = (ne.lat - sw.lat) * pad;\n    const y = (ne.lng - sw.lng) * pad;\n    return [\n        {\n            lat: sw.lat - x,\n            lng: sw.lng - y,\n        },\n        {\n            lat: ne.lat + x,\n            lng: ne.lng + y,\n        },\n    ];\n}\n","export const MAPBOX_API_KEY =\n    'pk.eyJ1IjoicGVsbWVycyIsImEiOiJjbDg5N2N5Nm0wMzU2M25qeHIzdjl5dm1pIn0.eIGsKaeGa_O7bELSprhD8A';\n"],"names":[],"sourceRoot":""}